\section{Einleitung}
\subsection{Ausgangslage}
Die Colomba Link GmbH entwickelt IoT-Lösungen für industrielle Anwendungen. Eines ihrer Produkte ist Monidas. Es besteht aus dem Sensorgerät Monidas Datadot ONE als HaaS zur Datenerfassung und der Monidas Plattform als SaaS. Über die Plattform lassen sich Organisationen, Projekte, Benutzer, Geräte sowie zugehörige Überwachungs- und Benachrichtigungsregeln erfassen und verwalten.  

Mit zunehmender Anzahl an Organisationen, Projekten, Sensoren und Regeln steigt der Aufwand für die Verwaltung und Pflege der Daten. Dies betrifft die technische Entwickler, welche die Konfiguration der Sensoren gemeinsam mit Kunden planen und umsetzen.

Im Rahmen eines Vorprojekts wurde eine alternative Konfigurationsumgebung zur bestehenden Webanwendung entwickelt. Ziel war es, in einem Proof of Concept zu evaluieren, wie sich die Plattformdaten über eine  Exploreransicht in VS Code bearbeiten lassen. Die bestehende hierarchische Struktur der Plattform wurde als virtuelles Filesystem abgebildet. Die Bearbeitung der Daten erfolgte über JSON Files im Editor. Die Umsetzung zeigte, dass sich das Grundkonzept technisch umsetzen lässt, machte jedoch auch Grenzen sichtbar.


\subsection{Problemstellung}
Durch das Vorprojekt wurde klar, dass die Konfigurationsdaten der Monidas-Plattform grundsätzlich über eine hierarchische Baumstruktur in VS Code dargestellt und bearbeitet werden können. Die Umsetzung zeigte, dass sich die vorhandene Webstruktur als virtuelles Filesystem abbilden lässt und sich die einzelnen Einträge über JSON-Files direkt im Editor bearbeiten lassen. Die dabei verwendete Struktur war jedoch fest im Quellcode definiert und basierte nicht auf dem zugrunde liegenden Datenmodell der Plattform.

Diese statische Definition führte dazu, dass jede Anpassung im Datenmodell auch eine Änderung in der Implementierung der Extension erforderte. Neue Felder, veränderte Typen oder zusätzliche Referenzen mussten manuell ergänzt werden. Dadurch entstand ein erhöhter Wartungsaufwand und eine enge Kopplung zwischen Anwendungslogik und Darstellung. Die Exploreransicht konnte nur dann aktualisiert werden, wenn alle Änderungen im Modell vorab bekannt und programmiert worden waren. Dies schränkte die Erweiterbarkeit der Lösung ein und machte sie anfällig für Inkonsistenzen.

Neben der Exploreransicht zeigte sich auch bei der Bearbeitung der JSON-Files im Editor ein Bedarf nach unterstützenden Funktionen. Es fehlten Mechanismen zur Validierung von Referenzen, zur Vorschlagserzeugung gültiger Werte oder zur Navigation zwischen verknüpften Einträgen. Diese Einschränkungen erschwerten die korrekte Eingabe und führten zu Fehlerquellen. Die vorhandene Lösung konnte nicht erkennen, ob ein Feld gültige Werte enthielt, ob eine Referenz korrekt war oder ob Eingaberegeln eingehalten wurden. Technische Nutzer mussten diese Prüfungen manuell durchführen, was den Aufwand erhöhte und die Nutzung erschwerte.

Ein weiteres Problem war die fehlende Trennung zwischen dem Datenmodell, der Dateistruktur und den Bearbeitungsregeln. Da alle Strukturelemente im Code definiert waren, konnte die Anwendung nicht auf veränderte Modelle reagieren. Es war nicht möglich, die Darstellung oder Bearbeitung ohne Quellcodeänderungen an neue Anforderungen anzupassen.

Die bisherige Architektur ist deshalb nicht in der Lage, mit einem dynamischen, schemabasierten System zu arbeiten. Es fehlt ein Mechanismus, der die Struktur und Bearbeitungslogik direkt aus dem Datenbankschema ableitet. Eine generische Lösung, die automatisch auf das definierte Modell reagiert, ist nicht vorhanden. Diese Einschränkungen sollen in der vorliegenden Arbeit adressiert werden. Ziel ist die Entwicklung einer Lösung, die das Datenmodell vollständig berücksichtigt und die Exploreransicht sowie die Bearbeitungslogik daraus ableitet.

\subsection{Fragestellung}
Das vorliegende Problem mit den oben beschriebenen Einschränkungen führt zu folgenden Fragestellungen:

\begin{itemize}
  \item Wie kann eine Explorerstruktur dynamisch aus einem schemabasierten Datenmodell erzeugt werden?
  \item Wie lassen sich Referenzen, Feldabhängigkeiten und Eingaberegeln im Editor prüfen und anzeigen?
  \item Welche Architektur erlaubt es, ein virtuelles Filesystem und einen Language Server auf Basis eines gemeinsamen Modells umzusetzen?
\end{itemize}

\subsection{Leserführung}
Was wird wo behandelt?